# Multi-Cycle ALU SystemVerilog Verification Environment

This repository contains the source code for a robust, modular verification environment designed to test a multi-cycle Arithmetic Logic Unit (ALU). The testbench is written entirely in **SystemVerilog** and follows a standard layered architecture, promoting reusability and a clean separation of concerns.

## Verification Architecture

The environment is built using a layered approach, separating the test, transaction, and signal layers. This architecture, commonly used in industry methodologies like UVM, allows for powerful and flexible verification.

* **Signal Layer:** The lowest level, containing the DUT and interfaces (`input_if`, `output_if`) that handle the physical pin wiggling.
* **Command Layer:** Consists of the **Driver** and **Monitor**. The Driver converts transactions into signal-level activity, while the Monitor observes signal activity and converts it back into transactions.
* **Transaction Layer:** The highest level of abstraction. It includes the **Generator** (creates input transactions), the **Model** (a behavioral or "golden" reference of the DUT), and the **Scoreboard** (compares outputs from the DUT and the Model to check for correctness).
* **Test Layer:** This is where specific tests are defined (e.g., `random_test`, `test_high`). Tests configure the environment and control the stimulus generated by the Generator.
* **Coverage:** Functional coverage points are collected to measure how thoroughly the DUT's features have been tested.

![Verification Architecture Diagram](systemverilog_verification_flow.png)

## File Structure

The project is organized into a hierarchical directory structure to maintain clarity and modularity.
 ├── hdl/ │ └── alu_multi_cycle.sv # The ALU DUT (Design Under Test) └── hvl/ ├── class_pkg.sv # Package containing all class definitions ├── environment_packages/ │ ├── Environment.sv # Top-level verification environment component │ ├── Generator.sv # Generates randomized stimulus (transactions) │ ├── Model.sv # Behavioral "golden" model of the ALU │ └── Scoreboard.sv # Compares DUT and Model outputs ├── interface_packages/ │ ├── alu_in_pkg/ # Components for the input agent │ │ ├── ALU_in_coverage.sv │ │ ├── ALU_in_driver.sv │ │ ├── ALU_in_if.sv │ │ ├── ALU_in_monitor.sv │ │ └── ALU_in_transaction.sv │ └── alu_out_pkg/ # Components for the output agent │ ├── ALU_out_coverage.sv │ ├── ALU_out_if.sv │ ├── ALU_out_monitor.sv │ └── ALU_out_transaction.sv ├── parameter_packages/ │ └── parameters.sv # Global parameters and definitions ├── tests/ │ ├── random_test.sv # Fully randomized test case │ ├── test_high.sv # Directed test for high operand values │ ├── test_mid.sv # Directed test for mid-range operand values │ └── test_mix.sv # Directed test with a mix of constraints └── top.sv # Testbench top module, connects DUT and test environment

## Available Tests

The `hvl/tests/` directory contains several tests to validate the DUT:

* **random\_test:** Generates fully randomized operand and opcode values to find unexpected corner cases.
* **test\_high:** A directed test that constrains operands to be in the higher end of their range.
* **test\_mid:** A directed test that constrains operands to be in the middle of their range.
* **test\_mix:** A directed test that uses a mix of different constraints to target specific scenarios.

## How to Run

To run a simulation, you will need a SystemVerilog-compliant simulator (e.g., Synopsys VCS, Cadence Xcelium, or Siemens Questa).

Compile all the SystemVerilog files and run the simulation by specifying which test you want to execute from the `top.sv` module. For example, using a generic simulator command:

```bash
# Example command to run the 'random_test'
your_simulator_command -f file_list.f +TESTNAME=random_test